#!/usr/bin/env python3
"""
PentestAgent渗透测试自动化集成模块
PentestAgent Penetration Testing Automation Integration Module

该模块负责与PentestAgent渗透测试自动化框架的集成，实现自动化的渗透测试执行
"""

import requests
import json
import time
import logging
from typing import Dict, List, Any, Optional
from pathlib import Path
import subprocess
import os

class PentestAgentIntegration:
    """
    PentestAgent渗透测试自动化集成类
    """

    def __init__(self, config_path: str = "automation_frameworks/pentest_agent_config.json"):
        """
        初始化PentestAgent集成

        Args:
            config_path: PentestAgent配置文件路径
        """
        self.config_path = config_path
        self.config = {}
        self.api_url = ""
        self.api_key = ""
        self.logger = logging.getLogger(__name__)

        self._load_config()
        self._setup_logging()

    def _load_config(self):
        """加载PentestAgent配置"""
        try:
            with open(self.config_path, 'r', encoding='utf-8') as f:
                self.config = json.load(f)

            self.api_url = self.config.get("api_url", "http://localhost:5000/api")
            self.api_key = self.config.get("api_key", "")
            self.logger.info("PentestAgent配置加载成功")

        except Exception as e:
            self.logger.error(f"PentestAgent配置加载失败: {e}")
            raise

    def _setup_logging(self):
        """设置日志"""
        self.logger.setLevel(logging.INFO)
        handler = logging.StreamHandler()
        formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
        handler.setFormatter(formatter)
        self.logger.addHandler(handler)

    def _make_api_request(self, method: str, endpoint: str, data: Optional[Dict] = None) -> Dict:
        """
        发送API请求

        Args:
            method: HTTP方法
            endpoint: API端点
            data: 请求数据

        Returns:
            API响应
        """
        url = f"{self.api_url}/{endpoint.lstrip('/')}"
        headers = {
            "Authorization": f"Bearer {self.api_key}",
            "Content-Type": "application/json"
        }

        try:
            if method.upper() == "GET":
                response = requests.get(url, headers=headers)
            elif method.upper() == "POST":
                response = requests.post(url, headers=headers, json=data)
            elif method.upper() == "PUT":
                response = requests.put(url, headers=headers, json=data)
            elif method.upper() == "DELETE":
                response = requests.delete(url, headers=headers)
            else:
                raise ValueError(f"不支持的HTTP方法: {method}")

            response.raise_for_status()
            return response.json()

        except requests.exceptions.RequestException as e:
            self.logger.error(f"API请求失败: {e}")
            return {}

    def _run_pentest_command(self, command: List[str], cwd: Optional[str] = None) -> Dict[str, Any]:
        """
        执行PentestAgent命令

        Args:
            command: 命令列表
            cwd: 工作目录

        Returns:
            执行结果
        """
        try:
            self.logger.info(f"执行PentestAgent命令: {' '.join(command)}")

            result = subprocess.run(
                command,
                cwd=cwd,
                capture_output=True,
                text=True,
                timeout=600
            )

            return {
                "success": result.returncode == 0,
                "returncode": result.returncode,
                "stdout": result.stdout,
                "stderr": result.stderr
            }

        except subprocess.TimeoutExpired:
            self.logger.error("PentestAgent命令执行超时")
            return {"success": False, "error": "命令执行超时"}
        except Exception as e:
            self.logger.error(f"PentestAgent命令执行失败: {e}")
            return {"success": False, "error": str(e)}

    def create_scan_task(self, scan_config: Dict) -> Optional[str]:
        """
        创建扫描任务

        Args:
            scan_config: 扫描配置

        Returns:
            任务ID
        """
        self.logger.info("创建扫描任务")

        response = self._make_api_request("POST", "scans", scan_config)
        if response and "task_id" in response:
            task_id = response["task_id"]
            self.logger.info(f"扫描任务创建成功，ID: {task_id}")
            return task_id

        self.logger.error("扫描任务创建失败")
        return None

    def start_scan(self, task_id: str) -> bool:
        """
        启动扫描

        Args:
            task_id: 任务ID

        Returns:
            是否启动成功
        """
        self.logger.info(f"启动扫描任务: {task_id}")

        response = self._make_api_request("POST", f"scans/{task_id}/start")
        if response and response.get("status") == "started":
            self.logger.info("扫描任务启动成功")
            return True

        self.logger.error("扫描任务启动失败")
        return False

    def get_scan_status(self, task_id: str) -> Dict[str, Any]:
        """
        获取扫描状态

        Args:
            task_id: 任务ID

        Returns:
            扫描状态
        """
        response = self._make_api_request("GET", f"scans/{task_id}/status")
        if response:
            return response

        return {"status": "unknown"}

    def get_scan_results(self, task_id: str) -> Dict[str, Any]:
        """
        获取扫描结果

        Args:
            task_id: 任务ID

        Returns:
            扫描结果
        """
        response = self._make_api_request("GET", f"scans/{task_id}/results")
        if response:
            return response

        return {}

    def create_exploit_task(self, exploit_config: Dict) -> Optional[str]:
        """
        创建漏洞利用任务

        Args:
            exploit_config: 漏洞利用配置

        Returns:
            任务ID
        """
        self.logger.info("创建漏洞利用任务")

        response = self._make_api_request("POST", "exploits", exploit_config)
        if response and "task_id" in response:
            task_id = response["task_id"]
            self.logger.info(f"漏洞利用任务创建成功，ID: {task_id}")
            return task_id

        self.logger.error("漏洞利用任务创建失败")
        return None

    def run_reconnaissance_scan(self, targets: List[str]) -> Dict[str, Any]:
        """
        运行侦察扫描

        Args:
            targets: 目标列表

        Returns:
            扫描结果
        """
        self.logger.info(f"开始侦察扫描，目标: {targets}")

        scan_config = {
            "name": "银狐木马侦察扫描",
            "type": "reconnaissance",
            "targets": targets,
            "modules": [
                "port_scan",
                "service_detection",
                "vulnerability_scan",
                "web_application_scan"
            ],
            "options": {
                "timing": "aggressive",
                "ports": "1-65535",
                "scripts": ["vulners", "http-vuln-*"],
                "output_format": "json"
            }
        }

        # 创建扫描任务
        task_id = self.create_scan_task(scan_config)
        if not task_id:
            return {"success": False, "error": "扫描任务创建失败"}

        # 启动扫描
        if not self.start_scan(task_id):
            return {"success": False, "error": "扫描启动失败"}

        # 等待扫描完成
        self.logger.info("等待扫描完成...")
        max_wait = 300  # 5分钟超时
        wait_time = 0
        while wait_time < max_wait:
            status = self.get_scan_status(task_id)
            if status.get("status") == "completed":
                break
            elif status.get("status") == "failed":
                return {"success": False, "error": "扫描失败"}

            time.sleep(10)
            wait_time += 10

        if wait_time >= max_wait:
            return {"success": False, "error": "扫描超时"}

        # 获取结果
        results = self.get_scan_results(task_id)
        return {"success": True, "task_id": task_id, "results": results}

    def run_vulnerability_assessment(self, targets: List[str], previous_results: Dict = None) -> Dict[str, Any]:
        """
        运行漏洞评估

        Args:
            targets: 目标列表
            previous_results: 之前的扫描结果

        Returns:
            评估结果
        """
        self.logger.info(f"开始漏洞评估，目标: {targets}")

        scan_config = {
            "name": "银狐木马漏洞评估",
            "type": "vulnerability_assessment",
            "targets": targets,
            "modules": [
                "nessus_scan",
                "openvas_scan",
                "nuclei_scan",
                "nikto_scan"
            ],
            "options": {
                "severity_threshold": "medium",
                "include_info_findings": False,
                "templates": ["cves", "exposed-panels", "misconfiguration"],
                "output_format": "json"
            }
        }

        if previous_results:
            scan_config["previous_scan"] = previous_results

        # 创建扫描任务
        task_id = self.create_scan_task(scan_config)
        if not task_id:
            return {"success": False, "error": "漏洞评估任务创建失败"}

        # 启动扫描
        if not self.start_scan(task_id):
            return {"success": False, "error": "漏洞评估启动失败"}

        # 等待完成
        max_wait = 600  # 10分钟超时
        wait_time = 0
        while wait_time < max_wait:
            status = self.get_scan_status(task_id)
            if status.get("status") == "completed":
                break
            elif status.get("status") == "failed":
                return {"success": False, "error": "漏洞评估失败"}

            time.sleep(15)
            wait_time += 15

        if wait_time >= max_wait:
            return {"success": False, "error": "漏洞评估超时"}

        # 获取结果
        results = self.get_scan_results(task_id)
        return {"success": True, "task_id": task_id, "results": results}

    def run_exploit_execution(self, vulnerabilities: List[Dict]) -> Dict[str, Any]:
        """
        运行漏洞利用执行

        Args:
            vulnerabilities: 漏洞列表

        Returns:
            利用结果
        """
        self.logger.info(f"开始漏洞利用执行，发现 {len(vulnerabilities)} 个漏洞")

        exploit_config = {
            "name": "银狐木马漏洞利用",
            "type": "automated_exploitation",
            "vulnerabilities": vulnerabilities,
            "options": {
                "safe_mode": True,
                "max_attempts": 3,
                "timeout": 300,
                "payload_delivery": "meterpreter",
                "cleanup_after_exploit": True
            }
        }

        # 创建利用任务
        task_id = self.create_exploit_task(exploit_config)
        if not task_id:
            return {"success": False, "error": "漏洞利用任务创建失败"}

        # 启动利用
        response = self._make_api_request("POST", f"exploits/{task_id}/execute")
        if not response or response.get("status") != "executing":
            return {"success": False, "error": "漏洞利用启动失败"}

        # 等待完成
        max_wait = 900  # 15分钟超时
        wait_time = 0
        while wait_time < max_wait:
            status = self._make_api_request("GET", f"exploits/{task_id}/status")
            if status.get("status") == "completed":
                break
            elif status.get("status") == "failed":
                return {"success": False, "error": "漏洞利用失败"}

            time.sleep(20)
            wait_time += 20

        if wait_time >= max_wait:
            return {"success": False, "error": "漏洞利用超时"}

        # 获取结果
        results = self._make_api_request("GET", f"exploits/{task_id}/results")
        return {"success": True, "task_id": task_id, "results": results}

    def run_comprehensive_pentest(self, targets: List[str]) -> Dict[str, Any]:
        """
        运行综合渗透测试

        Args:
            targets: 目标列表

        Returns:
            测试结果
        """
        self.logger.info(f"开始综合渗透测试，目标: {targets}")

        results = {
            "reconnaissance": {},
            "vulnerability_assessment": {},
            "exploitation": {},
            "overall_status": "running"
        }

        try:
            # 1. 侦察阶段
            recon_results = self.run_reconnaissance_scan(targets)
            results["reconnaissance"] = recon_results

            if not recon_results["success"]:
                results["overall_status"] = "failed"
                return results

            # 2. 漏洞评估阶段
            vuln_results = self.run_vulnerability_assessment(targets, recon_results.get("results"))
            results["vulnerability_assessment"] = vuln_results

            if not vuln_results["success"]:
                results["overall_status"] = "failed"
                return results

            # 3. 漏洞利用阶段
            vulnerabilities = vuln_results.get("results", {}).get("vulnerabilities", [])
            if vulnerabilities:
                exploit_results = self.run_exploit_execution(vulnerabilities)
                results["exploitation"] = exploit_results

                if exploit_results["success"]:
                    results["overall_status"] = "completed"
                else:
                    results["overall_status"] = "partial_success"
            else:
                self.logger.info("未发现可利用漏洞")
                results["overall_status"] = "completed"

        except Exception as e:
            self.logger.error(f"综合渗透测试失败: {e}")
            results["overall_status"] = "error"
            results["error"] = str(e)

        return results

    def generate_pentest_report(self, results: Dict, output_path: str) -> bool:
        """
        生成渗透测试报告

        Args:
            results: 测试结果
            output_path: 输出路径

        Returns:
            是否生成成功
        """
        self.logger.info(f"生成渗透测试报告: {output_path}")

        report_data = {
            "title": "银狐木马渗透测试报告",
            "timestamp": time.strftime("%Y-%m-%d %H:%M:%S"),
            "results": results,
            "summary": {
                "total_targets": len(results.get("reconnaissance", {}).get("results", {}).get("targets", [])),
                "vulnerabilities_found": len(results.get("vulnerability_assessment", {}).get("results", {}).get("vulnerabilities", [])),
                "exploits_successful": len(results.get("exploitation", {}).get("results", {}).get("successful_exploits", [])),
                "overall_status": results.get("overall_status", "unknown")
            }
        }

        try:
            with open(output_path, 'w', encoding='utf-8') as f:
                json.dump(report_data, f, indent=2, ensure_ascii=False)

            self.logger.info("渗透测试报告生成成功")
            return True

        except Exception as e:
            self.logger.error(f"渗透测试报告生成失败: {e}")
            return False


if __name__ == "__main__":
    # 测试PentestAgent集成
    pentest_agent = PentestAgentIntegration()

    # 运行综合渗透测试
    targets = ["mail-qq-tencent", "web-server", "192.168.1.100"]
    results = pentest_agent.run_comprehensive_pentest(targets)
    print(f"综合渗透测试结果: {results}")

    # 生成报告
    report_path = "/tmp/pentest_report.json"
    pentest_agent.generate_pentest_report(results, report_path)
    print(f"报告已生成: {report_path}")